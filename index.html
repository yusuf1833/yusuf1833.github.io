<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹¼è±†ç”Ÿæˆå™¨ - Perler Bead Generator</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <header class="header">
        <div class="container">
            <h1>ğŸ”® æ‹¼è±†ç”Ÿæˆå™¨</h1>
            <p class="subtitle">å°†å›¾ç‰‡è½¬æ¢ä¸ºæ‹¼è±†å›¾çº¸,æ”¯æŒå¤šå“ç‰Œè‰²å€¼</p>
        </div>
    </header>

    <main class="container">
        <div class="main-layout">
            <aside class="sidebar">
                <div class="control-panel">
                    <h3>è®¾ç½®é¢æ¿</h3>

                    <div class="form-group">
                        <label>é€‰æ‹©å“ç‰Œ</label>
                        <select id="brand-select" onchange="app.updateBrand()">
                            <option value="artkal">Artkal (é˜¿ç‰¹å¡å°”)</option>
                            <option value="mard">Mard (é©¬å¾—)</option>
                            <option value="manmanjia">æ¼«æ¼«å®¶</option>
                            <option value="perler">Perler (æ™®ä¹)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>æ‹¼è±†å°ºå¯¸</label>
                        <select id="bead-size" onchange="app.updateSettings()">
                            <option value="mini">è¿·ä½ è±† (2.6mm)</option>
                            <option value="standard" selected>æ ‡å‡†è±† (5mm)</option>
                            <option value="pegboard">å¤§æ¿ (10mm)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>å›¾çº¸å°ºå¯¸ (æ­£æ–¹å½¢æ ¼æ•°)</label>
                        <input type="range" id="grid-size-slider" min="8" max="200" value="29" oninput="app.updateGridSize(this.value)">
                        <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: #666; margin-top: 5px;">
                            <span>å½“å‰å°ºå¯¸: <span id="grid-size-display">29</span> x <span id="grid-size-height-display">29</span></span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>ç½‘æ ¼ç²’åº¦ (é‡‡æ ·ç»†èŠ‚)</label>
                        <input type="range" id="sampling-scale" min="1" max="20" value="8" oninput="app.updateSamplingScale(this.value)">
                        <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: #666; margin-top: 5px;">
                            <span>é‡‡æ ·å€ç‡: <span id="sampling-scale-display">8</span>x (è¶Šå°è¶Šé”åˆ©)</span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>é¢œè‰²åˆå¹¶ (å‡å°‘æ‚è‰²)</label>
                        <input type="range" id="merge-threshold" min="0" max="60" value="0" oninput="app.updateMergeSettings(this.value)">
                        <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: #666; margin-top: 5px;">
                            <span>æœ€å°åŒºåŸŸ: <span id="merge-threshold-display">0</span> æ ¼</span>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>é¢œè‰²æ•°é‡</label>
                        <input type="range" id="color-count" min="8" max="291" value="32" oninput="app.updateColorCount(this.value)">
                        <span id="color-count-display">32</span> ç§é¢œè‰²
                    </div>

                    <div class="form-group">
                        <label>å›¾åƒè°ƒæ•´</label>
                        <div class="adjustment-group">
                            <div class="adjustment-item">
                                <label>äº®åº¦</label>
                                <input type="range" id="brightness" min="-100" max="100" value="0" oninput="app.updateImageAdjustment()">
                                <span id="brightness-display">0</span>
                            </div>
                            <div class="adjustment-item">
                                <label>å¯¹æ¯”åº¦</label>
                                <input type="range" id="contrast" min="-100" max="100" value="0" oninput="app.updateImageAdjustment()">
                                <span id="contrast-display">0</span>
                            </div>
                            <div class="adjustment-item">
                                <label>é¥±å’Œåº¦</label>
                                <input type="range" id="saturation" min="-100" max="100" value="0" oninput="app.updateImageAdjustment()">
                                <span id="saturation-display">0</span>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>æ˜¾ç¤ºé€‰é¡¹</label>
                        <div class="checkbox-group">
                            <label>
                                <input type="checkbox" id="show-grid" checked onchange="app.render()">
                                æ˜¾ç¤ºç½‘æ ¼
                            </label>
                            <label>
                                <input type="checkbox" id="show-coordinates" checked onchange="app.render()">
                                æ˜¾ç¤ºåæ ‡
                            </label>
                            <label>
                                <input type="checkbox" id="show-color-codes" onchange="app.render()">
                                æ˜¾ç¤ºè‰²å€¼ä»£ç 
                            </label>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>ä¸Šä¼ å›¾ç‰‡</label>
                        <input type="file" id="image-upload" accept="image/*" onchange="app.handleImageUpload(event)">
                        <button class="btn btn-secondary" onclick="document.getElementById('image-upload').click()">é€‰æ‹©å›¾ç‰‡</button>
                        
                        <div id="image-preview-container" style="display: none; margin-top: 10px;">
                            <label style="font-size: 0.85rem; color: #666; margin-bottom: 5px; display: block;">åŸå›¾é¢„è§ˆ:</label>
                            <img id="image-preview" src="" alt="åŸå›¾é¢„è§ˆ" style="width: 100%; border-radius: 8px; border: 2px solid #e5e7eb;">
                            <button class="btn btn-secondary btn-block" style="margin-top: 8px; font-size: 0.9rem;" onclick="app.openImageEditor()">âœï¸ ç¼–è¾‘åŸå›¾ (æŠ å›¾)</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-primary btn-block" onclick="app.generatePattern()">ç”Ÿæˆæ‹¼è±†å›¾çº¸</button>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-refresh btn-block" onclick="app.refreshPattern()">ğŸ”„ åˆ·æ–°é…ç½®</button>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-repair btn-block" onclick="app.smartRepair()">ğŸ”§ æ™ºèƒ½ä¿®å¤</button>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-success btn-block" onclick="app.downloadPattern()">ä¸‹è½½å›¾çº¸ (PNG)</button>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-info btn-block" onclick="app.exportColorList()">å¯¼å‡ºè‰²å€¼åˆ—è¡¨</button>
                    </div>

                <div class="color-legend">
                    <h4>ä½¿ç”¨çš„é¢œè‰²</h4>
                    <div id="color-legend-content"></div>
                </div>
                </aside>

            <div class="content-area">
                <div class="preview-panel">
                    <div class="preview-header">
                        <h3>å›¾çº¸é¢„è§ˆ</h3>
                        <div class="zoom-controls">
                            <button onclick="app.zoom(-0.1)">-</button>
                            <span id="zoom-level">100%</span>
                            <button onclick="app.zoom(0.1)">+</button>
                        </div>
                    </div>
                    
                    <div class="edit-toolbar-inline">
                        <div class="edit-tools-row">
                            <div class="tool-group-inline">
                                <button id="tool-brush" class="tool-btn-inline active" onclick="app.selectTool('brush')" title="ç”»ç¬”">
                                    âœï¸
                                </button>
                                <button id="tool-fill" class="tool-btn-inline" onclick="app.selectTool('fill')" title="å¡«å……">
                                    ğŸª£
                                </button>
                                <button id="tool-eraser" class="tool-btn-inline" onclick="app.selectTool('eraser')" title="æ©¡çš®æ“¦">
                                    ğŸ§¹
                                </button>
                            </div>
                            <div class="color-picker-inline">
                                <input type="color" id="edit-color-inline" value="#FF0000" onchange="app.updateEditColor()">
                                <span id="edit-color-code-inline">A003</span>
                            </div>
                            <div class="action-group-inline">
                                <button class="action-btn-inline" onclick="app.undo()" title="æ’¤é”€">
                                    â†©ï¸
                                </button>
                                <button class="action-btn-inline" onclick="app.redo()" title="é‡åš">
                                    â†ªï¸
                                </button>
                            </div>
                            <button class="save-btn-inline" onclick="app.saveEdits()">ğŸ’¾</button>
                        </div>
                    </div>
                    
                    <div class="canvas-container" id="canvas-container">
                        <canvas id="pattern-canvas"></canvas>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="info-card">
                        <h4>ç»Ÿè®¡ä¿¡æ¯</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">æ€»æ ¼æ•°:</span>
                                <span class="stat-value" id="total-cells">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">ä½¿ç”¨é¢œè‰²:</span>
                                <span class="stat-value" id="used-colors">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">å“ç‰Œ:</span>
                                <span class="stat-value" id="current-brand">Artkal</span>
                            </div>
                        </div>
                    </div>

                    <div class="info-card">
                        <h4>ä½¿ç”¨è¯´æ˜</h4>
                        <ol>
                            <li>é€‰æ‹©æ‹¼è±†å“ç‰Œå’Œå°ºå¯¸</li>
                            <li>è®¾ç½®å›¾çº¸å¤§å°å’Œé¢œè‰²æ•°é‡</li>
                            <li>ä¸Šä¼ å›¾ç‰‡æˆ–ç›´æ¥ç”Ÿæˆç©ºç™½å›¾çº¸</li>
                            <li>ç‚¹å‡»"ç”Ÿæˆæ‹¼è±†å›¾çº¸"</li>
                            <li>ä¸‹è½½å›¾çº¸æˆ–å¯¼å‡ºè‰²å€¼åˆ—è¡¨</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <p>Â© 2024 æ‹¼è±†ç”Ÿæˆå™¨ | æ”¯æŒ Artkalã€Mardã€æ¼«æ¼«å®¶ã€Perler å¤šå“ç‰Œ</p>
    </footer>

    <!-- å›¾ç‰‡ç¼–è¾‘å™¨æ¨¡æ€æ¡† -->
    <div id="image-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ç¼–è¾‘åŸå›¾ (æŠ å›¾)</h3>
                <span class="close-modal" onclick="app.closeImageEditor()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="editor-toolbar">
                    <div class="tool-group">
                        <button id="img-tool-eraser" class="tool-btn active" onclick="app.setImageTool('eraser')" title="æ©¡çš®æ“¦ (å»é™¤èƒŒæ™¯)">ğŸ§¹ æ©¡çš®æ“¦</button>
                        <button id="img-tool-restore" class="tool-btn" onclick="app.setImageTool('restore')" title="æ¢å¤ç”»ç¬” (è¿˜åŸå†…å®¹)">ğŸ–Œï¸ æ¢å¤ç”»ç¬”</button>
                    </div>
                    <div class="tool-group">
                        <label>ç¬”åˆ·å¤§å°:</label>
                        <input type="range" id="brush-size" min="1" max="50" value="20" oninput="document.getElementById('brush-size-display').textContent = this.value">
                        <span id="brush-size-display">20</span>
                    </div>
                    <div class="tool-group">
                        <button class="tool-btn" onclick="app.undoImageEdit()" title="æ’¤é”€">â†©ï¸ æ’¤é”€</button>
                    </div>
                </div>
                <div class="editor-canvas-container">
                    <canvas id="image-editor-canvas"></canvas>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="app.closeImageEditor()">å–æ¶ˆ</button>
                    <button class="btn btn-primary" onclick="app.saveImageEditorChanges()">ä¿å­˜ä¿®æ”¹å¹¶é‡æ–°ç”Ÿæˆ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const app = {
            state: {
                brand: 'artkal',
                beadSize: 'standard',
                gridWidth: 29,
                gridHeight: 29,
                samplingScale: 8, // æ–°å¢é‡‡æ ·å€ç‡
                colorCount: 32,
                mergeThreshold: 0,
                showGrid: true,
                showCoordinates: true,
                showColorCodes: false,
                zoom: 1,
                brightness: 0,
                contrast: 0,
                saturation: 0,
                imageData: null,
                originalImageData: null, // æ–°å¢ï¼šä¿å­˜ç”¨æˆ·ä¸Šä¼ çš„æœ€åŸå§‹å›¾ç‰‡ï¼Œç”¨äºæ¢å¤
                pattern: null,
                colorMap: {},
                editTool: 'brush',
                editColor: null,
                editHistory: [],
                editHistoryIndex: -1,
                isMouseDown: false,
                
                // åŸå›¾ç¼–è¾‘ç›¸å…³çŠ¶æ€
                imgEditState: {
                    canvas: null,         // ç¼–è¾‘ç”»å¸ƒ
                    ctx: null,            // ç¼–è¾‘ä¸Šä¸‹æ–‡
                    tool: 'eraser',       // å½“å‰å·¥å…·ï¼šeraser æˆ– restore
                    isDrawing: false,
                    history: [],          // ç¼–è¾‘å†å²æ ˆ
                    historyIndex: -1,
                    brushSize: 20
                }
            },

            brands: {
                artkal: {
                    name: 'Artkal (å…¨è‰²åŸŸ 291è‰²)',
                    colors: [
                        { code: 'A001', name: 'é»‘è‰²', hex: '#000000' },
                        { code: 'A002', name: 'ç™½è‰²', hex: '#FFFFFF' },
                        { code: 'A003', name: 'çº¢è‰²', hex: '#FF0000' },
                        { code: 'A004', name: 'æ·±çº¢', hex: '#8B0000' },
                        { code: 'A005', name: 'æ©™è‰²', hex: '#FFA500' },
                        { code: 'A006', name: 'é»„è‰²', hex: '#FFFF00' },
                        { code: 'A007', name: 'ç»¿è‰²', hex: '#00FF00' },
                        { code: 'A008', name: 'æ·±ç»¿', hex: '#006400' },
                        { code: 'A009', name: 'è“è‰²', hex: '#0000FF' },
                        { code: 'A010', name: 'æ·±è“', hex: '#00008B' },
                        { code: 'A011', name: 'ç´«è‰²', hex: '#800080' },
                        { code: 'A012', name: 'ç²‰è‰²', hex: '#FFC0CB' },
                        { code: 'A013', name: 'æ£•è‰²', hex: '#A52A2A' },
                        { code: 'A014', name: 'ç°è‰²', hex: '#808080' },
                        { code: 'A015', name: 'æµ…ç°', hex: '#D3D3D3' },
                        { code: 'A016', name: 'é’è‰²', hex: '#00FFFF' },
                        { code: 'A017', name: 'æ´‹çº¢', hex: '#FF00FF' },
                        { code: 'A018', name: 'é‡‘è‰²', hex: '#FFD700' },
                        { code: 'A019', name: 'é“¶è‰²', hex: '#C0C0C0' },
                        { code: 'A020', name: 'æµ…è“', hex: '#ADD8E6' },
                        { code: 'A021', name: 'æµ…ç»¿', hex: '#90EE90' },
                        { code: 'A022', name: 'æµ…é»„', hex: '#FFFFE0' },
                        { code: 'A023', name: 'æµ…ç²‰', hex: '#FFB6C1' },
                        { code: 'A024', name: 'æµ…ç´«', hex: '#E6E6FA' },
                        { code: 'A025', name: 'æ·±æ©™', hex: '#FF8C00' },
                        { code: 'A026', name: 'æ·±é»„', hex: '#DAA520' },
                        { code: 'A027', name: 'æ·±é’', hex: '#008B8B' },
                        { code: 'A028', name: 'æ·±ç²‰', hex: '#DB7093' },
                        { code: 'A029', name: 'æ·±ç´«', hex: '#4B0082' },
                        { code: 'A030', name: 'æ·±æ£•', hex: '#8B4513' },
                        { code: 'A031', name: 'æµ…æ©™', hex: '#FFDAB9' },
                        { code: 'A032', name: 'æµ…çº¢', hex: '#FF6347' }
                    ]
                },
                mard: {
                    name: 'Mard (é©¬å¾—)',
                    colors: [
                        { code: 'M001', name: 'é»‘è‰²', hex: '#1A1A1A' },
                        { code: 'M002', name: 'ç™½è‰²', hex: '#F5F5F5' },
                        { code: 'M003', name: 'çº¢è‰²', hex: '#E63946' },
                        { code: 'M004', name: 'æ·±çº¢', hex: '#9D0208' },
                        { code: 'M005', name: 'æ©™è‰²', hex: '#F4A261' },
                        { code: 'M006', name: 'é»„è‰²', hex: '#E9C46A' },
                        { code: 'M007', name: 'ç»¿è‰²', hex: '#2A9D8F' },
                        { code: 'M008', name: 'æ·±ç»¿', hex: '#264653' },
                        { code: 'M009', name: 'è“è‰²', hex: '#457B9D' },
                        { code: 'M010', name: 'æ·±è“', hex: '#1D3557' },
                        { code: 'M011', name: 'ç´«è‰²', hex: '#9B5DE5' },
                        { code: 'M012', name: 'ç²‰è‰²', hex: '#F15BB5' },
                        { code: 'M013', name: 'æ£•è‰²', hex: '#8B5A2B' },
                        { code: 'M014', name: 'ç°è‰²', hex: '#6C757D' },
                        { code: 'M015', name: 'æµ…ç°', hex: '#E9ECEF' },
                        { code: 'M016', name: 'é’è‰²', hex: '#00B4D8' },
                        { code: 'M017', name: 'æ´‹çº¢', hex: '#F72585' },
                        { code: 'M018', name: 'é‡‘è‰²', hex: '#FFB703' },
                        { code: 'M019', name: 'é“¶è‰²', hex: '#ADB5BD' },
                        { code: 'M020', name: 'æµ…è“', hex: '#90E0EF' },
                        { code: 'M021', name: 'æµ…ç»¿', hex: '#80ED99' },
                        { code: 'M022', name: 'æµ…é»„', hex: '#FFFEA0' },
                        { code: 'M023', name: 'æµ…ç²‰', hex: '#FFC8DD' },
                        { code: 'M024', name: 'æµ…ç´«', hex: '#CDB4DB' },
                        { code: 'M025', name: 'æ·±æ©™', hex: '#FB8500' },
                        { code: 'M026', name: 'æ·±é»„', hex: '#FFB703' },
                        { code: 'M027', name: 'æ·±é’', hex: '#0077B6' },
                        { code: 'M028', name: 'æ·±ç²‰', hex: '#FF006E' },
                        { code: 'M029', name: 'æ·±ç´«', hex: '#7209B7' },
                        { code: 'M030', name: 'æ·±æ£•', hex: '#6B4423' },
                        { code: 'M031', name: 'æµ…æ©™', hex: '#FFD166' },
                        { code: 'M032', name: 'æµ…çº¢', hex: '#EF476F' }
                    ]
                },
                manmanjia: {
                    name: 'æ¼«æ¼«å®¶',
                    colors: [
                        { code: 'MM001', name: 'é»‘è‰²', hex: '#212529' },
                        { code: 'MM002', name: 'ç™½è‰²', hex: '#FFFFFF' },
                        { code: 'MM003', name: 'çº¢è‰²', hex: '#DC3545' },
                        { code: 'MM004', name: 'æ·±çº¢', hex: '#8B0000' },
                        { code: 'MM005', name: 'æ©™è‰²', hex: '#FD7E14' },
                        { code: 'MM006', name: 'é»„è‰²', hex: '#FFC107' },
                        { code: 'MM007', name: 'ç»¿è‰²', hex: '#28A745' },
                        { code: 'MM008', name: 'æ·±ç»¿', hex: '#155724' },
                        { code: 'MM009', name: 'è“è‰²', hex: '#007BFF' },
                        { code: 'MM010', name: 'æ·±è“', hex: '#004085' },
                        { code: 'MM011', name: 'ç´«è‰²', hex: '#6F42C1' },
                        { code: 'MM012', name: 'ç²‰è‰²', hex: '#E83E8C' },
                        { code: 'MM013', name: 'æ£•è‰²', hex: '#795548' },
                        { code: 'MM014', name: 'ç°è‰²', hex: '#6C757D' },
                        { code: 'MM015', name: 'æµ…ç°', hex: '#E9ECEF' },
                        { code: 'MM016', name: 'é’è‰²', hex: '#17A2B8' },
                        { code: 'MM017', name: 'æ´‹çº¢', hex: '#D63384' },
                        { code: 'MM018', name: 'é‡‘è‰²', hex: '#FFD700' },
                        { code: 'MM019', name: 'é“¶è‰²', hex: '#C0C0C0' },
                        { code: 'MM020', name: 'æµ…è“', hex: '#B3D9FF' },
                        { code: 'MM021', name: 'æµ…ç»¿', hex: '#A8E6CF' },
                        { code: 'MM022', name: 'æµ…é»„', hex: '#FFF9C4' },
                        { code: 'MM023', name: 'æµ…ç²‰', hex: '#FFB3E6' },
                        { code: 'MM024', name: 'æµ…ç´«', hex: '#D1C4E9' },
                        { code: 'MM025', name: 'æ·±æ©™', hex: '#E65100' },
                        { code: 'MM026', name: 'æ·±é»„', hex: '#F57F17' },
                        { code: 'MM027', name: 'æ·±é’', hex: '#006064' },
                        { code: 'MM028', name: 'æ·±ç²‰', hex: '#C2185B' },
                        { code: 'MM029', name: 'æ·±ç´«', hex: '#4A148C' },
                        { code: 'MM030', name: 'æ·±æ£•', hex: '#3E2723' },
                        { code: 'MM031', name: 'æµ…æ©™', hex: '#FFCC80' },
                        { code: 'MM032', name: 'æµ…çº¢', hex: '#EF5350' }
                    ]
                },
                perler: {
                    name: 'Perler (æ™®ä¹)',
                    colors: [
                        { code: 'P001', name: 'é»‘è‰²', hex: '#000000' },
                        { code: 'P002', name: 'ç™½è‰²', hex: '#FFFFFF' },
                        { code: 'P003', name: 'çº¢è‰²', hex: '#FF0000' },
                        { code: 'P004', name: 'æ·±çº¢', hex: '#8B0000' },
                        { code: 'P005', name: 'æ©™è‰²', hex: '#FFA500' },
                        { code: 'P006', name: 'é»„è‰²', hex: '#FFFF00' },
                        { code: 'P007', name: 'ç»¿è‰²', hex: '#008000' },
                        { code: 'P008', name: 'æ·±ç»¿', hex: '#006400' },
                        { code: 'P009', name: 'è“è‰²', hex: '#0000FF' },
                        { code: 'P010', name: 'æ·±è“', hex: '#00008B' },
                        { code: 'P011', name: 'ç´«è‰²', hex: '#800080' },
                        { code: 'P012', name: 'ç²‰è‰²', hex: '#FFC0CB' },
                        { code: 'P013', name: 'æ£•è‰²', hex: '#A52A2A' },
                        { code: 'P014', name: 'ç°è‰²', hex: '#808080' },
                        { code: 'P015', name: 'æµ…ç°', hex: '#D3D3D3' },
                        { code: 'P016', name: 'é’è‰²', hex: '#00FFFF' },
                        { code: 'P017', name: 'æ´‹çº¢', hex: '#FF00FF' },
                        { code: 'P018', name: 'é‡‘è‰²', hex: '#FFD700' },
                        { code: 'P019', name: 'é“¶è‰²', hex: '#C0C0C0' },
                        { code: 'P020', name: 'æµ…è“', hex: '#ADD8E6' },
                        { code: 'P021', name: 'æµ…ç»¿', hex: '#90EE90' },
                        { code: 'P022', name: 'æµ…é»„', hex: '#FFFFE0' },
                        { code: 'P023', name: 'æµ…ç²‰', hex: '#FFB6C1' },
                        { code: 'P024', name: 'æµ…ç´«', hex: '#E6E6FA' },
                        { code: 'P025', name: 'æ·±æ©™', hex: '#FF8C00' },
                        { code: 'P026', name: 'æ·±é»„', hex: '#DAA520' },
                        { code: 'P027', name: 'æ·±é’', hex: '#008B8B' },
                        { code: 'P028', name: 'æ·±ç²‰', hex: '#DB7093' },
                        { code: 'P029', name: 'æ·±ç´«', hex: '#4B0082' },
                        { code: 'P030', name: 'æ·±æ£•', hex: '#8B4513' },
                        { code: 'P031', name: 'æµ…æ©™', hex: '#FFDAB9' },
                        { code: 'P032', name: 'æµ…çº¢', hex: '#FF6347' }
                    ]
                }
            },

            init() {
                this.generateFullColorPalette();
                this.loadSettings();
                this.setupCanvas();
                this.render();
                this.updateStats();
                this.initEditTools();
            },

            generateFullColorPalette() {
                // ç¡®ä¿ Artkal æœ‰ 291 ä¸ªé¢œè‰²
                const artkal = this.brands.artkal;
                const existingCount = artkal.colors.length;
                const targetCount = 291;
                
                if (existingCount >= targetCount) return;
                
                // ä½¿ç”¨ HSL ç©ºé—´ç”Ÿæˆè¡¥å……é¢œè‰²ï¼Œç¡®ä¿è‰²åŸŸè¦†ç›–
                // æˆ‘ä»¬éœ€è¦ç”Ÿæˆ 291 - 32 = 259 ä¸ªé¢œè‰²
                
                let extIndex = 1;
                
                // 1. ç”Ÿæˆç°åº¦/é»‘ç™½è¡¥å…… (10ä¸ª)
                for (let i = 0; i < 10; i++) {
                    const l = Math.round(10 + (i / 9) * 80); // 10% - 90% Lightness
                    const hex = this.hslToHex(0, 0, l);
                    artkal.colors.push({
                        code: `EXT-G${extIndex++}`,
                        name: `è¡¥å……ç°${i+1}`,
                        hex: hex
                    });
                }
                
                // 2. ç”Ÿæˆå½©è‰²è¡¥å…… (249ä¸ª)
                // æŒ‰ç…§è‰²ç›¸ç¯ Hue 0-360 é‡‡æ ·
                // æ¯ä¸ªè‰²ç›¸ç”Ÿæˆå¤šä¸ªæ˜åº¦å’Œé¥±å’Œåº¦å˜ä½“
                
                const hues = 36; // 36ä¸ªè‰²ç›¸ï¼Œæ¯10åº¦ä¸€ä¸ª
                const variations = 7; // æ¯ä¸ªè‰²ç›¸7ä¸ªå˜ä½“
                // 36 * 7 = 252ï¼ŒåŠ ä¸Šä¹‹å‰çš„ç°åº¦ï¼Œè¶³å¤Ÿè¦†ç›–åˆ° 291
                
                for (let h = 0; h < 360; h += (360/hues)) {
                    // S: é¥±å’Œåº¦, L: äº®åº¦
                    // ç”Ÿæˆ 7 ç§å˜ä½“ï¼š
                    // é«˜é¥±å’Œ: äº®/ä¸­/æš—
                    // ä¸­é¥±å’Œ: äº®/ä¸­/æš—
                    // ä½é¥±å’Œ: ä¸­
                    
                    const vars = [
                        {s: 90, l: 80}, {s: 90, l: 50}, {s: 90, l: 30},
                        {s: 60, l: 80}, {s: 60, l: 50}, {s: 60, l: 30},
                        {s: 30, l: 50}
                    ];
                    
                    for (const v of vars) {
                        if (artkal.colors.length >= targetCount) break;
                        
                        const hex = this.hslToHex(h, v.s, v.l);
                        // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰é¢œè‰²å¤ªæ¥è¿‘ï¼ˆç®€å•çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼Œæˆ–è€…ç•¥è¿‡ï¼‰
                        // ä¸ºäº†æ€§èƒ½ï¼Œè¿™é‡Œç›´æ¥æ·»åŠ 
                        artkal.colors.push({
                            code: `EXT-${artkal.colors.length + 1}`,
                            name: `è¡¥å……è‰² ${artkal.colors.length + 1}`,
                            hex: hex
                        });
                    }
                }
                
                // å¦‚æœè¿˜ä¸å¤Ÿï¼Œè¡¥é½
                while (artkal.colors.length < targetCount) {
                    const hex = this.hslToHex(Math.random() * 360, 50 + Math.random() * 50, 20 + Math.random() * 60);
                    artkal.colors.push({
                        code: `EXT-${artkal.colors.length + 1}`,
                        name: `è¡¥å……è‰² ${artkal.colors.length + 1}`,
                        hex: hex
                    });
                }
            },
            
            hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
            },

            initEditTools() {
                this.state.editTool = 'brush';
                this.state.editColor = this.brands[this.state.brand].colors[2];
                document.getElementById('edit-color-inline').value = this.state.editColor.hex;
                document.getElementById('edit-color-code-inline').textContent = this.state.editColor.code;
                
                this.state.editHistory = [];
                this.state.editHistoryIndex = -1;
                
                this.bindCanvasEvents();
            },

            setupCanvas() {
                const canvas = document.getElementById('pattern-canvas');
                const container = document.getElementById('canvas-container');
                
                const width = this.state.gridWidth * 20 * this.state.zoom;
                const height = this.state.gridHeight * 20 * this.state.zoom;
                
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            },

            updateBrand() {
                this.state.brand = document.getElementById('brand-select').value;
                document.getElementById('current-brand').textContent = this.brands[this.state.brand].name;
                this.saveSettings();
                if (this.state.pattern) {
                    this.generatePattern();
                }
            },

            updateSettings() {
                this.state.beadSize = document.getElementById('bead-size').value;
                this.state.showGrid = document.getElementById('show-grid').checked;
                this.state.showCoordinates = document.getElementById('show-coordinates').checked;
                this.state.showColorCodes = document.getElementById('show-color-codes').checked;
                this.saveSettings();
                this.setupCanvas();
                if (this.state.pattern) {
                    this.generatePattern();
                } else {
                    this.render();
                }
            },

            updateGridSize(value) {
                const size = parseInt(value);
                
                // å¼ºåˆ¶ä½¿ç”¨ 1:1 çš„æ­£æ–¹å½¢å°ºå¯¸
                this.state.gridWidth = size;
                this.state.gridHeight = size;

                document.getElementById('grid-size-display').textContent = this.state.gridWidth;
                document.getElementById('grid-size-height-display').textContent = this.state.gridHeight;
                
                this.saveSettings();
                this.setupCanvas();
                
                // ä½¿ç”¨é˜²æŠ–ï¼Œé¿å…æ»‘åŠ¨æ—¶é¢‘ç¹ç”Ÿæˆ
                if (this.updateTimer) clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    if (this.state.pattern) {
                        this.generatePattern();
                    } else {
                        this.render();
                    }
                }, 100);
            },

            updateSamplingScale(value) {
                this.state.samplingScale = parseInt(value);
                document.getElementById('sampling-scale-display').textContent = this.state.samplingScale;
                this.saveSettings();
                
                // é˜²æŠ–æ›´æ–°
                if (this.updateTimer) clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    if (this.state.pattern) {
                        this.generatePattern();
                    }
                }, 100);
            },

            updateColorCount(value) {
                this.state.colorCount = parseInt(value);
                document.getElementById('color-count-display').textContent = value;
                this.saveSettings();
            },

            updateMergeSettings(value) {
                this.state.mergeThreshold = parseInt(value);
                document.getElementById('merge-threshold-display').textContent = value;
                this.saveSettings();
                
                // é˜²æŠ–æ›´æ–°
                if (this.updateTimer) clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    if (this.state.pattern) {
                        this.generatePattern();
                    }
                }, 100);
            },

            updateImageAdjustment() {
                this.state.brightness = parseInt(document.getElementById('brightness').value);
                this.state.contrast = parseInt(document.getElementById('contrast').value);
                this.state.saturation = parseInt(document.getElementById('saturation').value);

                document.getElementById('brightness-display').textContent = this.state.brightness;
                document.getElementById('contrast-display').textContent = this.state.contrast;
                document.getElementById('saturation-display').textContent = this.state.saturation;

                this.saveSettings();

                if (this.state.imageData) {
                    this.generatePattern();
                }
            },

            handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.state.imageData = img;
                        // ä¿å­˜ä¸€ä»½åŸå§‹å›¾ç‰‡å¤‡ä»½ï¼Œç”¨äºæ¢å¤
                        this.state.originalImageData = img.cloneNode(); 
                        
                        // æ˜¾ç¤ºé¢„è§ˆå›¾
                        const previewImg = document.getElementById('image-preview');
                        const previewContainer = document.getElementById('image-preview-container');
                        previewImg.src = e.target.result;
                        previewContainer.style.display = 'block';
                        
                        // é‡ç½®å¹¶é‡æ–°è®¡ç®—å°ºå¯¸
                        const slider = document.getElementById('grid-size-slider');
                        this.updateGridSize(slider.value);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            generatePattern() {
                if (!this.state.imageData) {
                    this.render();
                    return;
                }

                try {
                    const { gridWidth, gridHeight, brand, colorCount, brightness, contrast, saturation } = this.state;
                    const samplingScale = this.state.samplingScale || 8; // è·å–é‡‡æ ·å€ç‡ï¼Œé»˜è®¤ä¸º 8
                    const brandColors = this.brands[brand].colors.slice(0, colorCount);

                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // ä½¿ç”¨åŠ¨æ€çš„ scale
                    const scale = samplingScale;
                    tempCanvas.width = gridWidth * scale;
                    tempCanvas.height = gridHeight * scale;

                    tempCtx.imageSmoothingEnabled = true;
                    tempCtx.imageSmoothingQuality = 'high';
                    tempCtx.drawImage(this.state.imageData, 0, 0, gridWidth * scale, gridHeight * scale);
                    
                    let imageData = tempCtx.getImageData(0, 0, gridWidth * scale, gridHeight * scale);
                    
                    imageData = this.applyImageAdjustments(imageData, brightness, contrast, saturation);
                    imageData = this.applySharpen(imageData);
                    const edgeMap = this.detectEdges(imageData, gridWidth * scale, gridHeight * scale);
                    
                    const pixels = imageData.data;

                    this.state.pattern = [];
                    this.state.colorMap = {};

                    for (let y = 0; y < gridHeight; y++) {
                        const row = [];
                        for (let x = 0; x < gridWidth; x++) {
                            let totalR = 0, totalG = 0, totalB = 0, totalA = 0;
                            let edgeStrength = 0;
                            let count = 0;

                            for (let sy = 0; sy < scale; sy++) {
                                for (let sx = 0; sx < scale; sx++) {
                                    const px = x * scale + sx;
                                    const py = y * scale + sy;
                                    const i = (py * gridWidth * scale + px) * 4;
                                    
                                    totalR += pixels[i];
                                    totalG += pixels[i + 1];
                                    totalB += pixels[i + 2];
                                    totalA += pixels[i + 3];
                                    
                                    if (edgeMap[py] && edgeMap[py][px]) {
                                        edgeStrength += edgeMap[py][px];
                                    }
                                    
                                    count++;
                                }
                            }

                            let r = Math.round(totalR / count);
                            let g = Math.round(totalG / count);
                            let b = Math.round(totalB / count);
                            let a = Math.round(totalA / count);

                            // å¦‚æœé€æ˜åº¦ä½ï¼Œæˆ–è€…è¯¥ä½ç½®åŸæœ¬å°±æ˜¯ç©ºçš„ï¼ˆè¢«æ“¦é™¤ï¼‰ï¼Œåˆ™ä¸å¡«å……é¢œè‰²
                            if (a < 128) {
                                row.push(null);
                            } else {
                                const avgEdgeStrength = edgeStrength / count;
                                
                                if (avgEdgeStrength > 30) {
                                    r = Math.min(255, r * 1.2);
                                    g = Math.min(255, g * 1.2);
                                    b = Math.min(255, b * 1.2);
                                }
                                
                                const closestColor = this.findClosestColor(r, g, b, brandColors);
                                row.push(closestColor);
                                this.state.colorMap[closestColor.code] = closestColor;
                            }
                        }
                        this.state.pattern.push(row);
                    }

                    // åº”ç”¨é¢œè‰²åˆå¹¶ï¼ˆå»é™¤æ‚è‰²ï¼‰
                    if (this.state.mergeThreshold > 0) {
                        this.mergeSmallRegions(this.state.mergeThreshold);
                    }

                    this.applyContourCompensation();
                    this.render();
                    this.updateStats();
                    this.updateColorLegend();
                } catch (error) {
                    console.error('ç”Ÿæˆæ‹¼è±†å›¾çº¸æ—¶å‡ºé”™:', error);
                    alert('ç”Ÿæˆæ‹¼è±†å›¾çº¸å¤±è´¥: ' + error.message);
                }
            },

            applyImageAdjustments(imageData, brightness, contrast, saturation) {
                const data = imageData.data;
                const brightnessFactor = brightness;
                const contrastFactor = (contrast + 100) / 100;
                const saturationFactor = (saturation + 100) / 100;

                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i];
                    let g = data[i + 1];
                    let b = data[i + 2];

                    r += brightnessFactor;
                    g += brightnessFactor;
                    b += brightnessFactor;

                    r = Math.min(255, Math.max(0, r));
                    g = Math.min(255, Math.max(0, g));
                    b = Math.min(255, Math.max(0, b));

                    r = ((r - 128) * contrastFactor) + 128;
                    g = ((g - 128) * contrastFactor) + 128;
                    b = ((b - 128) * contrastFactor) + 128;

                    r = Math.min(255, Math.max(0, r));
                    g = Math.min(255, Math.max(0, g));
                    b = Math.min(255, Math.max(0, b));

                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    r = gray + saturationFactor * (r - gray);
                    g = gray + saturationFactor * (g - gray);
                    b = gray + saturationFactor * (b - gray);

                    data[i] = Math.min(255, Math.max(0, r));
                    data[i + 1] = Math.min(255, Math.max(0, g));
                    data[i + 2] = Math.min(255, Math.max(0, b));
                }

                return imageData;
            },

            enhanceContrast(imageData) {
                const data = imageData.data;
                const factor = 1.3;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, Math.max(0, ((data[i] - 128) * factor) + 128));
                    data[i + 1] = Math.min(255, Math.max(0, ((data[i + 1] - 128) * factor) + 128));
                    data[i + 2] = Math.min(255, Math.max(0, ((data[i + 2] - 128) * factor) + 128));
                }
                
                return imageData;
            },

            applySharpen(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const copy = new Uint8ClampedArray(data);
                
                const kernel = [
                    0, -1, 0,
                    -1, 5, -1,
                    0, -1, 0
                ];
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        for (let c = 0; c < 3; c++) {
                            let sum = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                    sum += copy[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                                }
                            }
                            data[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
                        }
                    }
                }
                
                return imageData;
            },

            detectEdges(imageData, width, height) {
                const data = imageData.data;
                const edgeMap = [];
                
                const sobelX = [
                    -1, 0, 1,
                    -2, 0, 2,
                    -1, 0, 1
                ];
                
                const sobelY = [
                    -1, -2, -1,
                    0, 0, 0,
                    1, 2, 1
                ];
                
                for (let y = 0; y < height; y++) {
                    edgeMap[y] = [];
                    for (let x = 0; x < width; x++) {
                        if (y === 0 || y === height - 1 || x === 0 || x === width - 1) {
                            edgeMap[y][x] = 0;
                            continue;
                        }
                        
                        let gx = 0, gy = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                
                                gx += gray * sobelX[kernelIdx];
                                gy += gray * sobelY[kernelIdx];
                            }
                        }
                        
                        edgeMap[y][x] = Math.sqrt(gx * gx + gy * gy);
                    }
                }
                
                return edgeMap;
            },

            mergeSmallRegions(threshold) {
                const { gridWidth, gridHeight, pattern } = this.state;
                if (!pattern) return;

                const visited = new Array(gridHeight).fill(0).map(() => new Array(gridWidth).fill(false));
                
                // éå†æ‰€æœ‰ç‚¹å¯»æ‰¾è¿é€šåŒºåŸŸ
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (!visited[y][x] && pattern[y][x] !== null) {
                            const region = this.findConnectedRegion(x, y, visited);
                            
                            // å¦‚æœåŒºåŸŸå¤§å°å°äºé˜ˆå€¼ï¼Œåˆ™è¿›è¡Œåˆå¹¶
                            if (region.pixels.length <= threshold) {
                                this.mergeRegionToNeighbors(region);
                            }
                        }
                    }
                }
            },

            findConnectedRegion(startX, startY, visited) {
                const { gridWidth, gridHeight, pattern } = this.state;
                const targetColor = pattern[startY][startX];
                const pixels = [];
                const queue = [[startX, startY]];
                visited[startY][startX] = true;
                
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // 4-neighbor connectivity
                
                while (queue.length > 0) {
                    const [x, y] = queue.shift();
                    pixels.push({x, y});
                    
                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                            if (!visited[ny][nx] && pattern[ny][nx] !== null && pattern[ny][nx].code === targetColor.code) {
                                visited[ny][nx] = true;
                                queue.push([nx, ny]);
                            }
                        }
                    }
                }
                
                return { pixels, color: targetColor };
            },

            mergeRegionToNeighbors(region) {
                const { gridWidth, gridHeight, pattern } = this.state;
                const neighborColors = {};
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]; // 8-neighbor for boundary check
                
                // ç»Ÿè®¡è¯¥åŒºåŸŸå¤–å›´çš„é¢œè‰²
                for (const pixel of region.pixels) {
                    for (const [dx, dy] of directions) {
                        const nx = pixel.x + dx;
                        const ny = pixel.y + dy;
                        
                        if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                            const neighborColor = pattern[ny][nx];
                            // å¿…é¡»æ˜¯æœ‰æ•ˆé¢œè‰²ï¼Œä¸”ä¸æ˜¯å½“å‰åŒºåŸŸçš„é¢œè‰²
                            if (neighborColor !== null && neighborColor.code !== region.color.code) {
                                neighborColors[neighborColor.code] = (neighborColors[neighborColor.code] || 0) + 1;
                            }
                        }
                    }
                }
                
                // æ‰¾åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„é‚»å±…é¢œè‰²
                let maxCount = 0;
                let bestColorCode = null;
                for (const code in neighborColors) {
                    if (neighborColors[code] > maxCount) {
                        maxCount = neighborColors[code];
                        bestColorCode = code;
                    }
                }
                
                // å¦‚æœæ‰¾åˆ°äº†é‚»å±…é¢œè‰²ï¼Œå°†æ•´ä¸ªåŒºåŸŸæ›¿æ¢ä¸ºè¯¥é¢œè‰²
                if (bestColorCode) {
                    // éœ€è¦ä» brands æ•°æ®æˆ– colorMap ä¸­æ‰¾åˆ°å¯¹åº”çš„é¢œè‰²å¯¹è±¡
                    // è¿™é‡Œå¯ä»¥ç›´æ¥ä» pattern ä¸­æ‰¾ä¸€ä¸ªç¤ºä¾‹ï¼Œæˆ–è€…ä½¿ç”¨ state.colorMap
                    // ä¸ºäº†å®‰å…¨ï¼Œæˆ‘ä»¬é‡æ–°æŸ¥æ‰¾
                    let targetColorObj = this.state.colorMap[bestColorCode];
                    
                    // å¦‚æœ colorMap ä¸­æ²¡æœ‰ï¼ˆä¸å¤ªå¯èƒ½ï¼‰ï¼Œå°è¯•ä»é‚»å±…ä¸­æŠ“ä¸€ä¸ª
                    if (!targetColorObj) {
                        // å¯»æ‰¾ä»»æ„ä¸€ä¸ªè¯¥é¢œè‰²çš„é‚»å±…
                        // ...çœç•¥å¤æ‚é€»è¾‘ï¼Œç›´æ¥ç”¨ colorMap åº”è¯¥æ²¡é—®é¢˜
                    }

                    if (targetColorObj) {
                        for (const pixel of region.pixels) {
                            pattern[pixel.y][pixel.x] = targetColorObj;
                        }
                    }
                }
            },

            applyContourCompensation() {
                const { gridWidth, gridHeight } = this.state;
                const pattern = this.state.pattern;
                // æ³¨æ„ï¼šè¿™é‡ŒåŸæœ¬ä¼šæŠŠç©ºæ´å¡«æˆé»‘è‰²ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦ç§»é™¤è¿™ä¸ªé€»è¾‘ï¼Œæˆ–è€…åªåœ¨éé€æ˜èƒŒæ™¯ä¸‹å¡«å……
                // å¦‚æœç”¨æˆ·å¸Œæœ›æŠ å›¾éƒ¨åˆ†æ˜¯ç™½è‰²çš„ï¼Œé‚£ä¹ˆè¿™é‡Œå°±ä¸åº”è¯¥å¼ºåˆ¶å¡«é»‘
                
                // æš‚æ—¶æ³¨é‡Šæ‰è¿™ä¸ªé€»è¾‘ï¼Œå› ä¸ºæŠ å›¾åä¸åº”è¯¥è‡ªåŠ¨æŠŠå‘¨å›´å¡«é»‘
                /*
                const blackColor = { code: 'BLACK', name: 'é»‘è‰²', hex: '#000000' };
                
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (pattern[y][x] !== null) {
                            const neighbors = this.getNeighborPositions(x, y);
                            for (const [nx, ny] of neighbors) {
                                if (pattern[ny][nx] === null) {
                                    pattern[ny][nx] = blackColor;
                                    this.state.colorMap['BLACK'] = blackColor;
                                }
                            }
                        }
                    }
                }
                */
            },

            getNeighborPositions(x, y) {
                const positions = [];
                const { gridWidth, gridHeight } = this.state;
                
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [1, -1], [-1, 1], [1, 1]
                ];
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        positions.push([nx, ny]);
                    }
                }
                
                return positions;
            },

            getNeighborColors(x, y) {
                const neighbors = [];
                const pattern = this.state.pattern;
                const { gridWidth, gridHeight } = this.state;
                
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [1, -1], [-1, 1], [1, 1]
                ];
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        if (pattern[ny][nx] !== null) {
                            neighbors.push(pattern[ny][nx]);
                        }
                    }
                }
                
                return neighbors;
            },

            getDominantColor(colors) {
                const colorCount = {};
                
                for (const color of colors) {
                    const key = color.code;
                    colorCount[key] = (colorCount[key] || 0) + 1;
                }
                
                let maxCount = 0;
                let dominant = colors[0];
                
                for (const color of colors) {
                    if (colorCount[color.code] > maxCount) {
                        maxCount = colorCount[color.code];
                        dominant = color;
                    }
                }
                
                return dominant;
            },

            smartRepair() {
                if (!this.state.pattern || this.state.pattern.length === 0) {
                    alert('è¯·å…ˆç”Ÿæˆæ‹¼è±†å›¾çº¸');
                    return;
                }

                this.removeNoise();
                this.smoothJaggedEdges();
                this.alignPixels();
                
                this.render();
                this.updateColorLegend();
                alert('æ™ºèƒ½ä¿®å¤å®Œæˆ!');
            },

            removeNoise() {
                const { gridWidth, gridHeight } = this.state;
                const pattern = this.state.pattern;
                let hasChanges = true;
                
                while (hasChanges) {
                    hasChanges = false;
                    
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            if (pattern[y][x] !== null) {
                                const neighbors = this.getNeighborColors(x, y);
                                const sameColorCount = neighbors.filter(n => n && n.code === pattern[y][x].code).length;
                                
                                if (neighbors.length > 0 && sameColorCount === 0) {
                                    const dominantColor = this.getDominantColor(neighbors);
                                    pattern[y][x] = dominantColor;
                                    hasChanges = true;
                                }
                            }
                        }
                    }
                }
            },

            smoothJaggedEdges() {
                const { gridWidth, gridHeight } = this.state;
                const pattern = this.state.pattern;
                const newPattern = JSON.parse(JSON.stringify(pattern));
                
                for (let y = 1; y < gridHeight - 1; y++) {
                    for (let x = 1; x < gridWidth - 1; x++) {
                        if (pattern[y][x] !== null) {
                            const currentColor = pattern[y][x];
                            const neighbors = this.getNeighborColors(x, y);
                            
                            if (neighbors.length >= 3) {
                                const colorGroups = {};
                                for (const n of neighbors) {
                                    if (n) {
                                        colorGroups[n.code] = (colorGroups[n.code] || 0) + 1;
                                    }
                                }
                                
                                const maxCount = Math.max(...Object.values(colorGroups));
                                if (maxCount >= 3) {
                                    const dominantCode = Object.keys(colorGroups).find(key => colorGroups[key] === maxCount);
                                    const dominantColor = neighbors.find(n => n && n.code === dominantCode);
                                    if (dominantColor && dominantColor.code !== currentColor.code) {
                                        newPattern[y][x] = dominantColor;
                                    }
                                }
                            }
                        }
                    }
                }
                
                this.state.pattern = newPattern;
            },

            alignPixels() {
                const { gridWidth, gridHeight } = this.state;
                const pattern = this.state.pattern;
                
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        if (pattern[y][x] !== null) {
                            const neighbors = this.getNeighborColors(x, y);
                            const sameColorNeighbors = neighbors.filter(n => n && n.code === pattern[y][x].code);
                            
                            if (sameColorNeighbors.length >= 2) {
                                const directions = [
                                    [-1, 0], [1, 0], [0, -1], [0, 1]
                                ];
                                
                                for (const [dx, dy] of directions) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    
                                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                                        if (pattern[ny][nx] === null) {
                                            const diagonalNeighbors = this.getDiagonalNeighbors(nx, ny);
                                            const sameDiagonal = diagonalNeighbors.filter(n => n && n.code === pattern[y][x].code);
                                            
                                            if (sameDiagonal.length >= 2) {
                                                pattern[ny][nx] = pattern[y][x];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            getDiagonalNeighbors(x, y) {
                const neighbors = [];
                const { gridWidth, gridHeight } = this.state;
                
                const directions = [
                    [-1, -1], [1, -1], [-1, 1], [1, 1]
                ];
                
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        if (this.state.pattern[ny][nx] !== null) {
                            neighbors.push(this.state.pattern[ny][nx]);
                        }
                    }
                }
                
                return neighbors;
            },

            refreshPattern() {
                if (this.state.imageData) {
                    this.generatePattern();
                } else {
                    this.render();
                }
                this.updateSettings();
            },

            findClosestColor(r, g, b, colors) {
                let minDistance = Infinity;
                let closest = colors[0];

                for (const color of colors) {
                    const distance = this.colorDistance(r, g, b, color.hex);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = color;
                    }
                }

                return closest;
            },

            colorDistance(r, g, b, hex) {
                const cr = parseInt(hex.slice(1, 3), 16);
                const cg = parseInt(hex.slice(3, 5), 16);
                const cb = parseInt(hex.slice(5, 7), 16);

                return Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );
            },

            render() {
                const canvas = document.getElementById('pattern-canvas');
                const ctx = canvas.getContext('2d');
                const { gridWidth, gridHeight, showGrid, showCoordinates, showColorCodes, zoom } = this.state;

                const cellSize = 20 * zoom;
                const offsetX = 30 * zoom;
                const offsetY = 30 * zoom;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const posX = offsetX + x * cellSize;
                        const posY = offsetY + y * cellSize;

                        const color = this.state.pattern && this.state.pattern[y] ? this.state.pattern[y][x] : null;

                        if (color) {
                            ctx.fillStyle = color.hex;
                            ctx.fillRect(posX + 1, posY + 1, cellSize - 2, cellSize - 2);
                        } else {
                            ctx.fillStyle = '#f5f5f5';
                            ctx.fillRect(posX + 1, posY + 1, cellSize - 2, cellSize - 2);
                        }

                        if (showGrid) {
                            ctx.strokeStyle = '#999999';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(posX, posY, cellSize, cellSize);
                        }

                        if (showColorCodes && color) {
                            ctx.fillStyle = this.getContrastColor(color.hex);
                            ctx.font = `bold ${10 * zoom}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(color.code, posX + cellSize / 2, posY + cellSize / 2);
                        }
                    }
                }

                if (showCoordinates) {
                    ctx.fillStyle = '#333333';
                    ctx.font = `bold ${12 * zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let x = 0; x < gridWidth; x++) {
                        ctx.fillText(x.toString(), offsetX + x * cellSize + cellSize / 2, offsetY - 12 * zoom);
                    }

                    ctx.textAlign = 'right';
                    for (let y = 0; y < gridHeight; y++) {
                        ctx.fillText(y.toString(), offsetX - 12 * zoom, offsetY + y * cellSize + cellSize / 2);
                    }
                }
            },

            getContrastColor(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                return brightness > 128 ? '#000000' : '#FFFFFF';
            },

            bindCanvasEvents() {
                const canvas = document.getElementById('pattern-canvas');
                
                canvas.addEventListener('mousedown', (e) => {
                    this.state.isMouseDown = true;
                    this.handleCanvasClick(e);
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.state.isMouseDown && this.state.editTool === 'brush') {
                        this.handleCanvasClick(e);
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.state.isMouseDown = false;
                    this.saveEditState();
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.state.isMouseDown = false;
                });
            },

            handleCanvasClick(e) {
                const canvas = document.getElementById('pattern-canvas');
                const rect = canvas.getBoundingClientRect();
                
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const cellSize = 20 * this.state.zoom;
                const offsetX = 30 * this.state.zoom;
                const offsetY = 30 * this.state.zoom;
                
                const gridX = Math.floor((x - offsetX) / cellSize);
                const gridY = Math.floor((y - offsetY) / cellSize);
                
                if (gridX >= 0 && gridX < this.state.gridWidth && 
                    gridY >= 0 && gridY < this.state.gridHeight) {
                    
                    if (this.state.editTool === 'brush') {
                        this.paintCell(gridX, gridY, this.state.editColor);
                    } else if (this.state.editTool === 'fill') {
                        this.fillArea(gridX, gridY, this.state.editColor);
                    } else if (this.state.editTool === 'eraser') {
                        this.paintCell(gridX, gridY, null);
                    }
                }
            },

            paintCell(x, y, color) {
                if (!this.state.pattern) return;
                
                const oldColor = this.state.pattern[y][x];
                if (oldColor === color) return;
                
                this.state.pattern[y][x] = color;
                this.state.colorMap[color ? color.code : 'erased'] = color || { code: 'erased', name: 'æ“¦é™¤', hex: '#f5f5f5' };
                
                this.render();
                this.updateColorLegend();
            },

            fillArea(startX, startY, fillColor) {
                if (!this.state.pattern) return;
                
                const targetColor = this.state.pattern[startY][startX];
                if (targetColor === fillColor) return;
                
                const visited = new Set();
                const stack = [[startX, startY]];
                const changes = [];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const key = `${x},${y}`;
                    
                    if (visited.has(key)) continue;
                    if (x < 0 || x >= this.state.gridWidth || y < 0 || y >= this.state.gridHeight) continue;
                    if (this.state.pattern[y][x] !== targetColor) continue;
                    
                    visited.add(key);
                    this.state.pattern[y][x] = fillColor;
                    changes.push({ x, y, oldColor: targetColor, newColor: fillColor });
                    
                    stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
                }
                
                if (changes.length > 0) {
                    this.state.colorMap[fillColor ? fillColor.code : 'erased'] = fillColor || { code: 'erased', name: 'æ“¦é™¤', hex: '#f5f5f5' };
                    this.render();
                    this.updateColorLegend();
                }
            },

            selectTool(tool) {
                this.state.editTool = tool;
                
                document.querySelectorAll('.tool-btn-inline').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`tool-${tool}`).classList.add('active');
            },

            updateEditColor() {
                const hex = document.getElementById('edit-color-inline').value;
                const brandColors = this.brands[this.state.brand].colors;
                
                let closestColor = brandColors[0];
                let minDistance = Infinity;
                
                for (const color of brandColors) {
                    const distance = this.colorDistance(
                        parseInt(hex.slice(1, 3), 16),
                        parseInt(hex.slice(3, 5), 16),
                        parseInt(hex.slice(5, 7), 16),
                        color.hex
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestColor = color;
                    }
                }
                
                this.state.editColor = closestColor;
                document.getElementById('edit-color-inline').value = closestColor.hex;
                document.getElementById('edit-color-code-inline').textContent = closestColor.code;
            },

            saveEditState() {
                if (!this.state.pattern) return;
                
                const patternCopy = JSON.parse(JSON.stringify(this.state.pattern));
                
                if (this.state.editHistoryIndex < this.state.editHistory.length - 1) {
                    this.state.editHistory = this.state.editHistory.slice(0, this.state.editHistoryIndex + 1);
                }
                
                this.state.editHistory.push(patternCopy);
                this.state.editHistoryIndex = this.state.editHistory.length - 1;
                
                if (this.state.editHistory.length > 50) {
                    this.state.editHistory.shift();
                    this.state.editHistoryIndex--;
                }
            },

            undo() {
                if (this.state.editHistory.length === 0) return;
                
                if (this.state.editHistoryIndex > 0) {
                    this.state.editHistoryIndex--;
                    this.state.pattern = JSON.parse(JSON.stringify(this.state.editHistory[this.state.editHistoryIndex]));
                    this.render();
                    this.updateColorLegend();
                } else if (this.state.editHistoryIndex === 0) {
                    this.state.editHistoryIndex = -1;
                    this.render();
                    this.updateColorLegend();
                }
            },

            redo() {
                if (this.state.editHistory.length === 0) return;
                
                if (this.state.editHistoryIndex < this.state.editHistory.length - 1) {
                    this.state.editHistoryIndex++;
                    this.state.pattern = JSON.parse(JSON.stringify(this.state.editHistory[this.state.editHistoryIndex]));
                    this.render();
                    this.updateColorLegend();
                }
            },

            saveEdits() {
                if (!this.state.pattern) {
                    alert('è¯·å…ˆç”Ÿæˆæ‹¼è±†å›¾çº¸');
                    return;
                }
                
                this.saveEditState();
                localStorage.setItem('bead_edited_pattern', JSON.stringify({
                    pattern: this.state.pattern,
                    colorMap: this.state.colorMap,
                    timestamp: Date.now()
                }));
                alert('ç¼–è¾‘å·²ä¿å­˜!');
            },

            updateStats() {
                const { gridWidth, gridHeight, colorMap } = this.state;
                document.getElementById('total-cells').textContent = gridWidth * gridHeight;
                document.getElementById('used-colors').textContent = Object.keys(colorMap).length;
            },

            countColors() {
                const counts = {};
                const { gridWidth, gridHeight, pattern } = this.state;
                if (!pattern) return counts;

                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const color = pattern[y][x];
                        if (color) {
                            counts[color.code] = (counts[color.code] || 0) + 1;
                        }
                    }
                }
                return counts;
            },

            updateColorLegend() {
                const container = document.getElementById('color-legend-content');
                container.innerHTML = '';

                const colors = Object.values(this.state.colorMap);
                const colorCounts = this.countColors();
                
                // æŒ‰è‰²å·æ’åº
                colors.sort((a, b) => a.code.localeCompare(b.code));
                
                colors.forEach(color => {
                    const count = colorCounts[color.code] || 0;
                    const div = document.createElement('div');
                    div.className = 'color-item';
                    div.innerHTML = `
                        <div class="color-swatch" style="background-color: ${color.hex}"></div>
                        <div class="color-info">
                            <span class="color-name">${color.name}</span>
                            <span class="color-code">${color.code}</span>
                        </div>
                        <div class="color-count" style="font-weight: bold; font-size: 0.9rem; color: #667eea; margin-left: 10px;">
                            ${count} ç²’
                        </div>
                    `;
                    container.appendChild(div);
                });
            },

            zoom(delta) {
                this.state.zoom = Math.max(0.2, Math.min(2, this.state.zoom + delta));
                document.getElementById('zoom-level').textContent = Math.round(this.state.zoom * 100) + '%';
                this.setupCanvas();
                this.render();
            },

            downloadPattern() {
                const canvas = document.getElementById('pattern-canvas');
                const colors = Object.values(this.state.colorMap);
                colors.sort((a, b) => a.code.localeCompare(b.code)); // Sort colors by code
                
                const downloadCanvas = document.createElement('canvas');
                const downloadCtx = downloadCanvas.getContext('2d');
                
                const patternWidth = canvas.width;
                const patternHeight = canvas.height;
                
                // Pass patternWidth to calculate dynamic height
                const legendHeight = this.calculateLegendHeight(colors.length, patternWidth);
                const totalHeight = patternHeight + legendHeight;
                
                downloadCanvas.width = patternWidth;
                downloadCanvas.height = totalHeight;
                
                downloadCtx.fillStyle = '#ffffff';
                downloadCtx.fillRect(0, 0, patternWidth, totalHeight);
                
                downloadCtx.drawImage(canvas, 0, 0);
                
                this.drawColorLegend(downloadCtx, patternHeight, patternWidth, colors);
                
                const link = document.createElement('a');
                link.download = `æ‹¼è±†å›¾çº¸_${this.brands[this.state.brand].name}_${Date.now()}.png`;
                link.href = downloadCanvas.toDataURL('image/png', 1.0);
                link.click();
            },

            calculateLegendHeight(colorCount, patternWidth) {
                // Dynamic columns based on width, min 200px per column
                const minColWidth = 200;
                const padding = 40;
                const availableWidth = patternWidth - padding;
                let cols = Math.floor(availableWidth / minColWidth);
                cols = Math.max(1, cols);
                
                const rows = Math.ceil(colorCount / cols);
                const itemHeight = 40;
                const headerHeight = 60;
                return headerHeight + rows * itemHeight + padding;
            },

            drawColorLegend(ctx, startY, width, colors) {
                const padding = 20;
                const headerHeight = 60;
                const itemHeight = 40;
                
                // Dynamic columns based on width, min 200px per column
                const minColWidth = 200;
                const availableWidth = width - padding * 2;
                let cols = Math.floor(availableWidth / minColWidth);
                cols = Math.max(1, cols);
                
                const itemWidth = availableWidth / cols;
                const colorCounts = this.countColors();
                
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, startY, width, ctx.canvas.height - startY);
                
                ctx.strokeStyle = '#dee2e6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, startY);
                ctx.lineTo(width, startY);
                ctx.stroke();
                
                ctx.fillStyle = '#333333';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`è‰²å€¼åˆ—è¡¨ - ${this.brands[this.state.brand].name}`, padding, startY + 15);
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#666666';
                ctx.fillText(`ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}`, padding, startY + 35);
                
                colors.forEach((color, index) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    
                    const x = padding + col * itemWidth;
                    const y = startY + headerHeight + row * itemHeight;
                    const count = colorCounts[color.code] || 0;
                    
                    ctx.fillStyle = color.hex;
                    ctx.fillRect(x, y + 5, 30, 30);
                    
                    ctx.strokeStyle = '#cccccc';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y + 5, 30, 30);
                    
                    ctx.fillStyle = '#333333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${color.code}`, x + 40, y + 20);
                    
                    ctx.fillStyle = '#666666';
                    ctx.font = '11px Arial';
                    ctx.fillText(color.name, x + 85, y + 20);
                    
                    ctx.fillStyle = '#e63946';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`${count}ç²’`, x + 150, y + 20);
                });
            },

            exportColorList() {
                const colors = Object.values(this.state.colorMap);
                if (colors.length === 0) {
                    alert('è¯·å…ˆç”Ÿæˆæ‹¼è±†å›¾çº¸');
                    return;
                }
                
                const colorCounts = this.countColors();
                colors.sort((a, b) => a.code.localeCompare(b.code));

                let content = `æ‹¼è±†è‰²å€¼åˆ—è¡¨\n`;
                content += `å“ç‰Œ: ${this.brands[this.state.brand].name}\n`;
                content += `ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}\n`;
                content += `ä½¿ç”¨é¢œè‰²æ•°: ${colors.length}\n`;
                content += `æ€»æ ¼æ•°: ${this.state.gridWidth * this.state.gridHeight}\n\n`;
                content += `è‰²å€¼ä»£ç \tæ•°é‡\té¢œè‰²åç§°\tåå…­è¿›åˆ¶\n`;
                content += `------------------------------------------------\n`;

                colors.forEach(color => {
                    const count = colorCounts[color.code] || 0;
                    content += `${color.code}\t${count}\t${color.name}\t${color.hex}\n`;
                });

                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.download = `è‰²å€¼åˆ—è¡¨_${this.brands[this.state.brand].name}_${Date.now()}.txt`;
                link.href = URL.createObjectURL(blob);
                link.click();
            },

            saveSettings() {
                localStorage.setItem('bead_settings', JSON.stringify({
                    brand: this.state.brand,
                    beadSize: this.state.beadSize,
                    gridWidth: this.state.gridWidth,
                    gridHeight: this.state.gridHeight,
                    samplingScale: this.state.samplingScale, // ä¿å­˜é‡‡æ ·è®¾ç½®
                    mergeThreshold: this.state.mergeThreshold,
                    colorCount: this.state.colorCount,
                    brightness: this.state.brightness,
                    contrast: this.state.contrast,
                    saturation: this.state.saturation,
                    showGrid: this.state.showGrid,
                    showCoordinates: this.state.showCoordinates,
                    showColorCodes: this.state.showColorCodes
                }));
            },

            loadSettings() {
                const saved = localStorage.getItem('bead_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        this.state = { ...this.state, ...settings };
                        // ç¡®ä¿ imageData ä¸è¢« settings è¦†ç›–ï¼ˆå› ä¸º settings é‡Œæ²¡æœ‰å­˜å›¾ï¼‰
                        // å®é™…ä¸Š settings é‡Œåªå­˜äº†é…ç½®é¡¹ï¼Œåº”è¯¥ä¸ä¼šè¦†ç›– imageDataï¼Œä½†ä¸ºäº†å®‰å…¨èµ·è§è¦æ³¨æ„
                        
                        document.getElementById('brand-select').value = this.state.brand;
                        document.getElementById('bead-size').value = this.state.beadSize;
                        
                        // æ¢å¤æ»‘å—å€¼ï¼ˆå–é•¿è¾¹ï¼‰
                        const maxSide = Math.max(this.state.gridWidth, this.state.gridHeight);
                        const slider = document.getElementById('grid-size-slider');
                        if (slider) {
                            slider.value = maxSide;
                            document.getElementById('grid-size-display').textContent = this.state.gridWidth;
                            document.getElementById('grid-size-height-display').textContent = this.state.gridHeight;
                        }

                        document.getElementById('sampling-scale').value = this.state.samplingScale || 8;
                        document.getElementById('sampling-scale-display').textContent = this.state.samplingScale || 8;

                        document.getElementById('merge-threshold').value = this.state.mergeThreshold || 0;
                        document.getElementById('merge-threshold-display').textContent = this.state.mergeThreshold || 0;

                        document.getElementById('color-count').value = this.state.colorCount;
                        document.getElementById('color-count-display').textContent = this.state.colorCount;
                        document.getElementById('brightness').value = this.state.brightness || 0;
                        document.getElementById('contrast').value = this.state.contrast || 0;
                        document.getElementById('saturation').value = this.state.saturation || 0;
                        document.getElementById('brightness-display').textContent = this.state.brightness || 0;
                        document.getElementById('contrast-display').textContent = this.state.contrast || 0;
                        document.getElementById('saturation-display').textContent = this.state.saturation || 0;
                        document.getElementById('show-grid').checked = this.state.showGrid;
                        document.getElementById('show-coordinates').checked = this.state.showCoordinates;
                        document.getElementById('show-color-codes').checked = this.state.showColorCodes;
                        document.getElementById('current-brand').textContent = this.brands[this.state.brand].name;
                    } catch (e) {
                        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', e);
                    }
                }
            },

            // --- åŸå›¾ç¼–è¾‘åŠŸèƒ½ ---

            openImageEditor() {
                if (!this.state.imageData) {
                    alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡');
                    return;
                }

                const modal = document.getElementById('image-editor-modal');
                // å…ˆæ˜¾ç¤ºæ¨¡æ€æ¡†ï¼Œç¡®ä¿èƒ½è·å–åˆ°æ­£ç¡®çš„å®¹å™¨å°ºå¯¸
                modal.style.display = 'block';

                // ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å·²ç»æ¸²æŸ“ï¼Œèƒ½å¤Ÿè·å–æ­£ç¡®çš„ clientWidth/clientHeight
                setTimeout(() => {
                    // 1. å…ˆç»‘å®šäº‹ä»¶ï¼ˆè¿™ä¼šæ›¿æ¢ DOM èŠ‚ç‚¹ï¼Œé‡ç½® Canvasï¼‰
                    // å¿…é¡»å…ˆåšè¿™ä¸€æ­¥ï¼Œå¦åˆ™ç»˜åˆ¶çš„å†…å®¹ä¼šè¢«æ–° Canvas è¦†ç›–æ‰
                    this.bindImageEditorEvents();
                    
                    // 2. è·å–æœ€æ–°çš„ Canvas å’Œ Context (ç”± bindImageEditorEvents æ›´æ–°)
                    const canvas = this.state.imgEditState.canvas;
                    const ctx = this.state.imgEditState.ctx;
                    
                    // åˆå§‹åŒ–å†å²è®°å½•
                    this.state.imgEditState.history = [];
                    this.state.imgEditState.historyIndex = -1;
                    
                    // 3. è®¡ç®—å°ºå¯¸
                    const img = this.state.imageData;
                    const modalBody = modal.querySelector('.modal-body');
                    const editorContainer = modal.querySelector('.editor-canvas-container');
                    
                    // è·å–å®¹å™¨çš„å®é™…å¯ç”¨ç©ºé—´
                    const containerWidth = editorContainer.clientWidth;
                    const containerHeight = editorContainer.clientHeight;
                    
                    if (containerWidth === 0 || containerHeight === 0) {
                        console.error('Canvas container size is 0');
                        return;
                    }
                    
                    let width = img.width;
                    let height = img.height;
                    
                    // ç¼©æ”¾ä»¥é€‚åº”å±å¹• (ä¿ç•™ä¸€ç‚¹è¾¹è·)
                    const padding = 20;
                    const availableWidth = containerWidth - padding * 2;
                    const availableHeight = containerHeight - padding * 2;
                    
                    const scale = Math.min(1, Math.min(availableWidth / width, availableHeight / height));
                    
                    // 4. è®¾ç½® Canvas å°ºå¯¸
                    canvas.width = width;
                    canvas.height = height;
                    
                    // è®¾ç½®æ˜¾ç¤ºå°ºå¯¸ï¼ˆCSSï¼‰
                    canvas.style.width = (width * scale) + 'px';
                    canvas.style.height = (height * scale) + 'px';
                    canvas.style.display = 'block'; // ç¡®ä¿æ˜¾ç¤º
                    
                    // 5. ç»˜åˆ¶å›¾ç‰‡
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0);
                    
                    // 6. ä¿å­˜åˆå§‹çŠ¶æ€
                    this.saveImageHistory();
                    
                    // 7. é»˜è®¤å·¥å…·
                    this.setImageTool('eraser');
                }, 50); // ç¨å¾®å¢åŠ å»¶æ—¶ï¼Œç¡®ä¿å¸ƒå±€ç¨³å®š
            },
            
            closeImageEditor() {
                const modal = document.getElementById('image-editor-modal');
                modal.style.display = 'none';
                
                // è§£ç»‘äº‹ä»¶ï¼ˆå¯é€‰ï¼Œç®€åŒ–èµ·è§è¿™é‡Œä¸å¼ºåˆ¶è§£ç»‘ï¼Œå› ä¸ºæ¨¡æ€æ¡†éšè—äº†ï¼‰
            },
            
            setImageTool(tool) {
                this.state.imgEditState.tool = tool;
                
                // æ›´æ–°UI
                document.getElementById('img-tool-eraser').classList.remove('active');
                document.getElementById('img-tool-restore').classList.remove('active');
                document.getElementById(`img-tool-${tool}`).classList.add('active');
                
                const canvas = document.getElementById('image-editor-canvas');
                if (tool === 'eraser') {
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'cell';
                }
            },
            
            bindImageEditorEvents() {
                const canvas = document.getElementById('image-editor-canvas');
                
                // ç§»é™¤æ—§çš„ç›‘å¬å™¨ä»¥é˜²é‡å¤ç»‘å®š
                const newCanvas = canvas.cloneNode(true);
                canvas.parentNode.replaceChild(newCanvas, canvas);
                this.state.imgEditState.canvas = newCanvas;
                this.state.imgEditState.ctx = newCanvas.getContext('2d');
                
                // é‡æ–°ç»‘å®š
                newCanvas.addEventListener('mousedown', this.handleImageEditStart.bind(this));
                newCanvas.addEventListener('mousemove', this.handleImageEditMove.bind(this));
                newCanvas.addEventListener('mouseup', this.handleImageEditEnd.bind(this));
                newCanvas.addEventListener('mouseleave', this.handleImageEditEnd.bind(this));
                
                // è§¦æ‘¸æ”¯æŒ
                newCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
                    this.handleImageEditStart(e.touches[0]);
                });
                newCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleImageEditMove(e.touches[0]);
                });
                newCanvas.addEventListener('touchend', this.handleImageEditEnd.bind(this));
            },
            
            getCanvasCoordinates(e) {
                const canvas = this.state.imgEditState.canvas;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            },
            
            handleImageEditStart(e) {
                this.state.imgEditState.isDrawing = true;
                const { x, y } = this.getCanvasCoordinates(e);
                this.drawOnImage(x, y);
            },
            
            handleImageEditMove(e) {
                if (!this.state.imgEditState.isDrawing) return;
                const { x, y } = this.getCanvasCoordinates(e);
                this.drawOnImage(x, y);
            },
            
            handleImageEditEnd() {
                if (this.state.imgEditState.isDrawing) {
                    this.state.imgEditState.isDrawing = false;
                    this.saveImageHistory();
                }
            },
            
            drawOnImage(x, y) {
                const ctx = this.state.imgEditState.ctx;
                const size = parseInt(document.getElementById('brush-size').value);
                const tool = this.state.imgEditState.tool;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                
                if (tool === 'eraser') {
                    // æ©¡çš®æ“¦ï¼šæ¸…é™¤åƒç´ ï¼ˆå˜é€æ˜ï¼‰
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = 'rgba(0,0,0,1)';
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over'; // æ¢å¤é»˜è®¤
                } else if (tool === 'restore') {
                    // æ¢å¤ç”»ç¬”ï¼šä»åŸå§‹å›¾ç‰‡ç»˜åˆ¶å›æ¥
                    // è¿™é‡Œåˆ©ç”¨ clip() å’Œ drawImage æ¥å®ç°å±€éƒ¨æ¢å¤
                    ctx.save();
                    ctx.clip(); // å°†å½“å‰è·¯å¾„ï¼ˆåœ†å½¢ï¼‰ä½œä¸ºå‰ªåˆ‡åŒºåŸŸ
                    
                    // ç¡®ä¿æˆ‘ä»¬æœ‰åŸå§‹å›¾ç‰‡
                    const originalImg = this.state.originalImageData || this.state.imageData;
                    
                    // åœ¨å‰ªåˆ‡åŒºåŸŸå†…ç»˜åˆ¶åŸå§‹å›¾ç‰‡
                    // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ç»˜åˆ¶æ•´ä¸ªåŸå§‹å›¾ç‰‡ï¼Œä½†å› ä¸ºæœ‰ clip()ï¼Œåªæœ‰åœ†å½¢åŒºåŸŸä¼šè¢«ç»˜åˆ¶å‡ºæ¥
                    // ä¸”å› ä¸ºæ˜¯ source-overï¼Œå®ƒä¼šè¦†ç›–åœ¨å½“å‰é€æ˜æˆ–è¢«ä¿®æ”¹çš„åŒºåŸŸä¸Š
                    ctx.clearRect(x - size - 1, y - size - 1, size * 2 + 2, size * 2 + 2); // å…ˆæ¸…é™¤è¯¥åŒºåŸŸï¼Œé˜²æ­¢åŠé€æ˜å åŠ 
                    ctx.drawImage(originalImg, 0, 0, ctx.canvas.width, ctx.canvas.height);
                    
                    ctx.restore();
                }
            },
            
            saveImageHistory() {
                const { canvas, history, historyIndex } = this.state.imgEditState;
                
                // å¦‚æœå½“å‰ä¸åœ¨å†å²è®°å½•æœ«å°¾ï¼Œåˆ™åˆ é™¤åé¢çš„è®°å½•
                if (historyIndex < history.length - 1) {
                    this.state.imgEditState.history = history.slice(0, historyIndex + 1);
                }
                
                // ä¿å­˜å½“å‰çŠ¶æ€ï¼ˆImageDataï¼‰
                const imageData = this.state.imgEditState.ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.state.imgEditState.history.push(imageData);
                this.state.imgEditState.historyIndex++;
                
                // é™åˆ¶å†å²è®°å½•é•¿åº¦
                if (this.state.imgEditState.history.length > 20) {
                    this.state.imgEditState.history.shift();
                    this.state.imgEditState.historyIndex--;
                }
            },
            
            undoImageEdit() {
                const { ctx, history, historyIndex } = this.state.imgEditState;
                
                if (historyIndex > 0) {
                    this.state.imgEditState.historyIndex--;
                    const prevImageData = history[this.state.imgEditState.historyIndex];
                    ctx.putImageData(prevImageData, 0, 0);
                }
            },
            
            saveImageEditorChanges() {
                const canvas = this.state.imgEditState.canvas;
                
                // å°†Canvaså†…å®¹è½¬æ¢ä¸ºImageå¯¹è±¡
                const newImg = new Image();
                newImg.onload = () => {
                    this.state.imageData = newImg;
                    
                    // æ›´æ–°é¢„è§ˆå›¾
                    const previewImg = document.getElementById('image-preview');
                    previewImg.src = newImg.src;
                    
                    // å…³é—­æ¨¡æ€æ¡†
                    this.closeImageEditor();
                    
                    // é‡æ–°ç”Ÿæˆå›¾çº¸
                    this.generatePattern();
                    
                    alert('å›¾ç‰‡ä¿®æ”¹å·²åº”ç”¨ï¼Œå›¾çº¸å·²æ›´æ–°');
                };
                newImg.src = canvas.toDataURL('image/png');
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>